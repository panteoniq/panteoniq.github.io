[ { "title": "[MariaDB 10.4] ", "url": "/posts/Mariadb_10_4/", "categories": "Development, DB", "tags": "MariaDB, MySQL", "date": "2022-11-16 20:38:53 +0900", "snippet": "MariaDB 10.4 이상의 변경점MariaDB는 현재 (22년 11월 기준) 10.11까지 릴리즈된 상태이다. 이 중 MariaDB 10.4를 기점으로 몇 가지 굵직한 변화가 있었는데 이에 대해 설명하고자 한다.mysql.user가 테이블에서 뷰로 변경테이블은 실제로 데이터가 존재하는 공간이기 때문에 Insert 및 Update가 가능하지만 View는 테이블의 일부 데이터를 간추려 테이블처럼 제공하기 때문에 Insert 및 Update를 실행할 수 없으며 View에 존재하는 데이터 또한 실제로 존재하는 데이터가 아니라 테이블에서 가져온 데이터를 가상의 공간에서 보여주는 역할을 한다.mysql.user가 테이블에서 뷰로 변경됨에 따라 참고해야 할 내용은 다음과 같다mysql.global_priv 테이블 신규 추가DB에 접속할 수 있는 사용자 및 주소, 권한을 표시하던 user 테이블 대신 이를 대체하는 신규 테이블인 global_priv가 추가되었다.# MariaDB 10.3MariaDB [mysql]&gt; show tables;+---------------------------+| Tables_in_mysql |+---------------------------+| .... || general_log || gtid_slave_pos || help_category || .... || time_zone_transition || time_zone_transition_type || transaction_registry || user |+---------------------------+# MariaDB 10.4MariaDB [mysql]&gt; show tables;+---------------------------+| Tables_in_mysql |+---------------------------+| .... || general_log || global_priv || gtid_slave_pos || help_category || help_keyword || .... || transaction_registry || user |+---------------------------+공식 홈페이지에서는 mysql.user 테이블을 대체하고자 추가되었다고 짤막하게 설명되어 있는데, 권한에 다양한 값을 넣을 수 있도록 하기 위한 의도가 아니었을까 싶다. 실제로 global_priv 테이블의 description 및 내용을 확인해보면+-------+----------+------+-----+---------+-------+| Field | Type | Null | Key | Default | Extra |+-------+----------+------+-----+---------+-------+| Host | char(60) | NO | PRI | | || User | char(80) | NO | PRI | | || Priv | longtext | NO | | '{}' | |+-------+----------+------+-----+---------+-------++-----------------------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------+| Host | User | Priv |+-----------------------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------+| localhost | mariadb.sys | {\"access\":0,\"plugin\":\"mysql_native_password\",\"authentication_string\":\"\",\"account_locked\":true,\"password_last_changed\":0} || localhost | root | {\"access\":18446744073709551615,\"plugin\":\"mysql_native_password\",\"authentication_string\":\"invalid\",\"auth_or\":[{},{\"plugin\":\"unix_socket\"}]} || localhost | mysql | {\"access\":18446744073709551615,\"plugin\":\"mysql_native_password\",\"authentication_string\":\"invalid\",\"auth_or\":[{},{\"plugin\":\"unix_socket\"}]} || localhost | | {} || localhost.localdomain | | {} |+-----------------------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------+description에서는 권한을 나타내는 Priv 컬럼의 자료형은 longText, default는 json처럼 빈 중괄호 쌍으로 되어있는 것을 확인할 수 있다. 그리고 데이터를 조회해보면 json과 동일한 방식으로 권한 데이터를 출력하고 있다. 단순히 1-depth가 아니라 내부에 여러 depth를 담을 수 있도록 되어있다.이 테이블의 추가로 인해 mysql.user는 View로 변경되었고, 이로 인해 아래의 각 항목들 내용에서 알 수 있듯이 계정 정보를 변경하기 위해 사용했던 질의문에도 여러가지 변경사항이 생겼다.mysql.user에 직접 사용자 계정 추가하는 쿼리 실행 불가MariaDB 10.3까지는 mysql.user에 직접 데이터를 insert함으로써 신규 사용자 계정을 추가할 수 있었다.INSERT INTO `user` (`Host`,`User`,`Password`,`Select_priv`,`Insert_priv`,`Update_priv`,`Delete_priv`,`Create_priv`,`Drop_priv`,`Reload_priv`,`Shutdown_priv`,`Process_priv`,`File_priv`,`Grant_priv`,`References_priv`,`Index_priv`,`Alter_priv`,`Show_db_priv`,`Super_priv`,`Create_tmp_table_priv`,`Lock_tables_priv`,`Execute_priv`,`Repl_slave_priv`,`Repl_client_priv`,`ssl_type`,`ssl_cipher`,`x509_issuer`,`x509_subject`,`max_questions`,`max_updates`,`max_connections`) VALUES (\"%\",\"testuser\",password(\"plain_password\"),\"Y\",\"Y\",\"Y\",\"Y\",\"Y\",\"Y\",\"Y\",\"Y\",\"Y\",\"Y\",\"Y\",\"Y\",\"Y\",\"Y\",\"Y\",\"N\",\"N\",\"Y\",\"N\",\"Y\",\"Y\",\"\",\"\",\"\",\"\",\"0\",\"0\",\"0\");하지만 INSERT가 불가능한 VIEW의 특성 상 MariaDB 10.4부터 mysql.user에 INSERT로 직접 사용자를 추가하는 것은 불가능하다. 그럼 신규 사용자를 추가하려면 어떻게 해야 할까? CREATE USER 쿼리를 쓰면 된다. 다만 비밀번호는 평문으로밖에 지정할 수 없다는 점은 유의해야 한다.CREATE USER 'testuser'@'localhost' IDENTIFIED BY 'plane_password';만약 암호화된 비밀번호를 직접 지정하고 싶을 경우 아래의 쿼리를 이용하면 된다. 안타깝게도 사용자 생성과 동시에 고정된 암호화 비밀번호를 사용하는 단일 쿼리는 현재까지 본 적이 없으며 구글링해도 나오지 않는다.ALTER USER 'root'@'localhost' IDENTIFIED VIA mysql_native_password USING '*7ADAB7F58141BB2B38C885DEBF9630543D42DE20'; /*password('plain_password')*/mysql.user로 직접 권한 변경 불가mysql.user에 사용자를 추가하는 쿼리를 봤다면 어마무시하게 많은 권한 목록도 같이 봤을 것이다. 총 30개의 권한이 있으며 그 종류는 다음과 같다 Field Type Null Key Default Description   Select_priv enum('N','Y') NO   N Can perform SELECT statements.   Insert_priv enum('N','Y') NO   N Can perform INSERT statements.   Update_priv enum('N','Y') NO   N Can perform UPDATE statements.   Delete_priv enum('N','Y') NO   N Can perform DELETE statements.   Create_priv enum('N','Y') NO   N Can CREATE DATABASE’s or CREATE TABLE’s.   Drop_priv enum('N','Y') NO   N Can DROP DATABASE’s or DROP TABLE’s.   Reload_priv enum('N','Y') NO   N Can execute FLUSH statements or equivalent mysqladmin commands.   Shutdown_priv enum('N','Y') NO   N Can shut down the server with SHUTDOWN or mysqladmin shutdown.   Process_priv enum('N','Y') NO   N Can show information about active processes, via SHOW PROCESSLIST or mysqladmin processlist.   File_priv enum('N','Y') NO   N Read and write files on the server, using statements like LOAD DATA INFILE or functions like LOAD_FILE(). Also needed to create CONNECT outward tables. MariaDB server must have permission to access those files.   Grant_priv enum('N','Y') NO   N User can grant privileges they possess.   References_priv enum('N','Y') NO   N Unused   Index_priv enum('N','Y') NO   N Can create an index on a table using the CREATE INDEX statement. Without the INDEX privilege, user can still create indexes when creating a table using the CREATE TABLE statement if the user has have the CREATE privilege, and user can create indexes using the ALTER TABLE statement if they have the ALTER privilege.   Alter_priv enum('N','Y') NO   N Can perform ALTER TABLE statements.   Show_db_priv enum('N','Y') NO   N Can list all databases using the SHOW DATABASES statement. Without the SHOW DATABASES privilege, user can still issue the SHOW DATABASES statement, but it will only list databases containing tables on which they have privileges.   Super_priv enum('N','Y') NO   N Can execute superuser statements: CHANGE MASTER TO, KILL (users who do not have this privilege can only KILL their own threads), PURGE LOGS, SET global system variables, or the mysqladmin debug command. Also, this permission allows the user to write data even if the read_only startup option is set, enable or disable logging, enable or disable replication on slaves, specify a DEFINER for statements that support that clause, connect once after reaching the MAX_CONNECTIONS. If a statement has been specified for the init-connect mysqld option, that command will not be executed when a user with SUPER privileges connects to the server.   Create_tmp_table_priv enum('N','Y') NO   N Can create temporary tables with the CREATE TEMPORARY TABLE statement.   Lock_tables_priv enum('N','Y') NO   N Acquire explicit locks using the LOCK TABLES statement; user also needs to have the SELECT privilege on a table in order to lock it.   Execute_priv enum('N','Y') NO   N Can execute stored procedure or functions.   Repl_slave_priv enum('N','Y') NO   N Accounts used by slave servers on the master need this privilege. This is needed to get the updates made on the master.   Repl_client_priv enum('N','Y') NO   N Can execute SHOW MASTER STATUS and SHOW SLAVE STATUS statements.   Create_view_priv enum('N','Y') NO   N Can create a view using the CREATE_VIEW statement.   Show_view_priv enum('N','Y') NO   N Can show the CREATE VIEW statement to create a view using the SHOW CREATE VIEW statement.   Create_routine_priv enum('N','Y') NO   N Can create stored programs using the CREATE PROCEDURE and CREATE FUNCTION statements.   Alter_routine_priv enum('N','Y') NO   N Can change the characteristics of a stored function using the ALTER FUNCTION statement.   Create_user_priv enum('N','Y') NO   N Can create a user using the CREATE USER statement, or implicitly create a user with the GRANT statement.   Event_priv enum('N','Y') NO   N Create, drop and alter events.   Trigger_priv enum('N','Y') NO   N Can execute triggers associated with tables the user updates, execute the CREATE TRIGGER and DROP TRIGGER statements.   Create_tablespace_priv enum('N','Y') NO   N     Delete_history_priv enum('N','Y') NO   N Can delete rows created through system versioning.   이 권한 값들은 global_priv.priv 컬럼 내 access 항목에 각각 2^(순번-1)의 값을 bit 연산한 값으로 저장되어 있다. 다음의 예시를 보면 이해가 빠를 것이다. Select_priv와 Insert_priv 2^0 + 2^1 =&gt; 3 Select_priv ~ Drop_priv까지 2^0 + 2^1 + .... + 2^5 = 2^6-1 =&gt; 63 따라서 권한을 지정하고 싶을 경우, global_priv 테이블의 데이터를 직접 수정해야만 한다.각 권한별 값은 다음과 같다. 권한 저장 시, 필요한 권한에 해당하는 값을 모두 더해서 저장하면 된다UPDATE global_priv SET Priv = JSON_SET(Priv, '$.access', 33521663) WHERE user='{사용자명}'; Select_priv : 1 (2^0) Insert_priv : 2 (2^1) Update_priv : 4 (2^2) Delete_priv : 8 (2^3) Create_priv : 16 (2^4) Drop_priv : 32 (2^5) Reload_priv : 64 (2^6) Shutdown_priv : 128 (2^7) Process_priv : 256 (2^8) File_priv : 512 (2^9) Grant_priv : 1024 (2^10) References_priv : 2048 (2^11) Index_priv : 4096 (2^12) Alter_priv : 8192 (2^13) Show_db_priv : 16384 (2^14) Super_priv : 32768 (2^15) Create_tmp_table_priv : 65536 (2^16) Lock_tables_priv : 131072 (2^17) Execute_priv : 262144 (2^18) Repl_slave_priv : 524288 (2^19) Repl_client_priv : 1048576 (2^20) Create_view_priv : 2097152 (2^21) Show_view_priv : 4194304 (2^22) Create_routine_priv : 8388608 (2^23) Alter_routine_priv : 16777216 (2^24) Create_user_priv : 33554432 (2^25) Event_priv : 67108864 (2^26) Trigger_priv 134217728 (2^27) Create_tablespace_priv 268435456 (2^28) Delete_history_priv 536870912 (2^29) 만약 모든 권한을 주고 싶다면 권한 값을 모두 더하는 것 이외에도 unsigned BIGINT의 MAX 값을 지정해도 된다+-----------------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------+| Host | User | Priv |+-----------------------+-------------+------------------------------------------------------------------------------------------------------------------------------------------------------+| localhost | mariadb.sys | {\"access\":0,\"plugin\":\"mysql_native_password\",\"authentication_string\":\"\",\"account_locked\":true,\"password_last_changed\":0} || localhost | root | {\"access\":18446744073709551615,\"plugin\":\"mysql_native_password\",\"authentication_string\":\"invalid\",\"auth_or\":[{},{\"plugin\":\"unix_socket\"}]} 두번째 행의 priv.access 항목을 보면 값이 18446744073709551615로 되어있는데 이는 mysql에서 unsigned BIGINT의 max값이기도 하다 (2^64-1)mysql.user로 직접 비밀번호 변경 불가mysql.user가 View로 바뀌어서 다음과 같이 직접 비밀번호를 바꾸는 쿼리는 실행할 수 없다UPDATE user SET Password=password('plain_password') WHERE User=\"root\";UPDATE user SET Password=ENCRYPTEDPASSWORD WHERE User=\"root\";실행하면 다음 에러가 발생한다ERROR 1356 (HY000) at line 2: View 'mysql.user' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them특정 계정의 비밀번호를 변경하기 위해서는 아래 2가지의 방법이 있다 global_priv 테이블의 데이터를 직접 변경 UPDATE global_priv SET Priv = JSON_SET(Priv, '$.plugin', 'mysql_native_password', '$.authentication_ string', 'ENCRYPTED PASSWORD') WHERE user='testuser'; UPDATE global_priv SET Priv = JSON_SET(Priv, '$.plugin', 'mysql_native_password', '$.authentication_ string', password('plain password')) WHERE user='testuser'; plugin field에 입력되는 플러그인 목록은 https://mariadb.com/kb/en/authentication-plugins/에 기록되어 있다. mysql_install_db 명령어 실행으로 생성된 root@localhost의 경우 unix_socket 플러그인과 mysql_native_password 플러그인 2개가 기본 지정되어 있다. 각 플러그인에 대한 자세한 설명은 별도 포스팅으로 다룰 예정 ALTER USER 쿼리로 사용자 정보 변경 ALTER USER '{사용자}'@'localhost' IDENTIFIED VIA mysql_native_password USING 'ENCRYPTED PASSWORD'; ALTER USER '{사용자}'@'localhost' IDENTIFIED VIA mysql_native_password USING password('plain password)'; Datadir 지정 시 에러 주의과거에는 MySQL의 데이터가 저장되는 기본 디렉토리는 /var/lib/mysql 이며 my.cnf 파일에서 [mysqld] 하위의 ‘datadir’ 항목의 값을 변경하여 데이터 저장 디렉토리를 변경할 수 있었다.[mysqld]datadir=/home/user/MysqlData...하지만 MariaDB 10.4 이상부터는 datadir 값을 변경하면 다음의 에러가 발생한다● mariadb.service - MariaDB 10.4.21 database server Loaded: loaded (/usr/lib/systemd/system/mariadb.service; enabled; vendor preset: disabled) Drop-In: /etc/systemd/system/mariadb.service.d └─migrated-from-my.cnf-settings.conf Active: failed (Result: exit-code) since Tue 2021-11-02 20:38:34 KST; 8s ago Docs: man:mysqld(8) https://mariadb.com/kb/en/library/systemd/ Process: 1218 ExecStartPost=/bin/sh -c systemctl unset-environment _WSREP_START_POSITION (code=exited, status=0/SUCCESS) Process: 19165 ExecStart=/usr/sbin/mysqld $MYSQLD_OPTS $_WSREP_NEW_CLUSTER $_WSREP_START_POSITION (code=exited, status=1/FAILURE) Process: 19151 ExecStartPre=/bin/sh -c [ ! -e /usr/bin/galera_recovery ] &amp;&amp; VAR= || VAR=`cd /usr/bin/..; /usr/bin/galera_recovery`; [ $? -eq 0 ] &amp;&amp; systemctl set-environment _WSREP_START_POSITION=$VAR || exit 1 (code=exited, status=0/SUCCESS) Process: 19149 ExecStartPre=/bin/sh -c systemctl unset-environment _WSREP_START_POSITION (code=exited, status=0/SUCCESS) Main PID: 19165 (code=exited, status=1/FAILURE) Status: \"MariaDB server is down\"하지만 이것만으로는 도저히 에러가 발생하는 원인을 파악할 수 없으며 이 에러는 에러로그가 별도로 기록되지도 않는다. 즉 my.cnf의 [mysqld] 하위에 log-error 항목에 에러로그가 저장될 경로를 지정해도 에러는 하나도 기록되지 않는다는 뜻이다.이 에러는 datadir를 지정하기 전 /usr/lib/systemd/system/mariadb.service 파일을 열어 ProtectHome 항목을 다음과 같이 변경한다# Prevent accessing /home, /root and /run/userProtectHome=false이후 systemctl daemon-reload 명령어를 실행해 변경된 설정을 mariadb가 다시 reload하도록 한 후 DB를 시작하면 정상적으로 동작하는 것을 볼 수 있다[참고사항]만약 이렇게 했음에도 정상 실행이 되지 않는다면, 다음 사항을 확인하라 /etc/my.cnf에 datadir 설정이 올바른지 확인 datadir로 지정된 디렉토리의 권한이 mysql:mysql인지 확인 권한이 mysql로 지정되어 있지 않으면 실행 중 에러가 발생한다 OS의 root 계정에서 MariaDB의 root 계정 비밀번호를 묻지 않음MariaDB 10.3에서는 DB의 root 계정에 비밀번호를 부여하면 서버의 사용자가 root이더라도 DB의 root와는 다른 사용자로 간주하고 항상 비밀번호를 물어본다.[root@MariaDB_10_3 ~]# mysql -urootERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO)하지만 MariaDB 10.4에서는 현재 사용자 계정이 root라면 mysql의 root 계정과 동일한 권한을 가진 것으로 판단하고 비밀번호가 없어도 접속을 시켜준다.MariaDB [mysql]&gt; select host, user, password from user;+----------------+-------------+-------------------------------------------+| Host | User | Password |+----------------+-------------+-------------------------------------------+| localhost | mariadb.sys | || localhost | root | *6C1A9647D6568F85D5BB7620F80042D4CA4CF7A0 | &lt;--- 분명 root 계정에 패스워드가 설정되어 있음에도..| localhost | | || mariadb\\_10\\_4 | | |+----------------+-------------+-------------------------------------------+4 rows in set (0.001 sec)MariaDB [mysql]&gt; Bye[root@MariaDB_10_4 ~]# mysql -uroot &lt;---- 비밀번호 없이 root 계정으로 접속하면Welcome to the MariaDB monitor. Commands end with ; or \\g.Your MariaDB connection id is 11Server version: 10.4.22-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.MariaDB [(none)]&gt; &lt;----- 접속이 된다이는 root의 기본 인증 방식 때문에 그렇다. global_priv 테이블을 보면 root 계정의 정보가 다음과 같이 기록되어 있는데MariaDB [mysql]&gt; select * from global_priv;+----------------+-------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Host | User | Priv |+----------------+-------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+ | localhost | root | {\"access\":18446744073709551615,\"plugin\":\"mysql_native_password\",\"authentication_string\":\"...\",\"auth_or\":[{},{\"plugin\":\"unix_socket\"}],\"password_last_changed\":1637239255} || localhost | | {} || mariadb\\_10\\_4 | | {} |+----------------+-------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+여기에서 우리는 plugin 항목의 unix_socket이라는 부분에 주목할 필요가 있다. MariaDB 홈페이지에는 이 plugin에 대해 다음과 같이 설명하고 있다.First, it is configured to try to use the unix_socket authentication plugin. This allows the root@localhost user to login without a password via the local Unix socket file defined by the socket system variable, as long as the login is attempted from a process owned by the operating system root user account.즉 이 plugin이 있으면 사용자 계정이 root@localhost인 경우에는 MariaDB의 root 계정으로 접속할 때 비밀번호를 묻지 않는다는 것이다.따라서 root 계정으로 접속하는 것을 막으려면 이 plugin을 우선 제거한 뒤 임의의 비밀번호를 설정해 MariaDB의 root 계정을 사용하지 못하도록 해야 한다.plugin을 제거하려면 다음 쿼리를 실행하면 된다ALTER USER root@localhost IDENTIFIED VIA mysql_native_password USING {Encrypted Password}// 수정 전MariaDB [mysql]&gt; select * from global_priv;+-----------------------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Host | User | Priv |+-----------------------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| localhost | root | {\"access\": 1073741823, \"plugin\": \"mysql_native_password\", \"authentication_string\": \"...\", \"auth_or\": [{}, {\"plugin\": \"unix_socket\"}]}+-----------------------+-------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+// 수정 후MariaDB [mysql]&gt; select * from global_priv;+-----------------------+-------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Host | User | Priv |+-----------------------+-------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| localhost | root | {\"access\": 549755813887, \"plugin\": \"mysql_native_password\", \"authentication_string\": \"...\", \"auth_or\": [{}],\"version_id\":100603,\"password_last_changed\":1634023497} |+-----------------------+-------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+// 수정 후 mysql에 접속 시도한 결과[root@MariaDB_10_4 ~]# mysql -urootERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO) &lt;--- 사용자가 root@localhost 계정임에도 비밀번호 없이 DB의 root 계정으로 접속할 수 없다[root@MariaDB_10_4 ~]# mysql -uroot -pEnter password: &lt;----- 반드시 비밀번호를 입력해야 접속할 수 있다Welcome to the MariaDB monitor. Commands end with ; or \\g.Your MariaDB connection id is 14Server version: 10.4.22-MariaDB MariaDB ServerCopyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.MariaDB [(none)]&gt;" }, { "title": "[UDS] Unix Domain Socket", "url": "/posts/unix_domain_socket/", "categories": "Development, Etc", "tags": "UDS, Socket", "date": "2022-11-10 21:07:25 +0900", "snippet": "UDS?Unix Domain Socket, 짧게 줄여 UDS는 일반적으로 우리가 사용하는 TCP/UDP와는 조금 다른 개념이다. TCP/UDP는 네트워크 통신을 하는 반면 UDS는 파일시스템 내부의 파일을 이용해 통신한다.네트워크를 사용하지 않고 어떻게 통신을 하느냐고 물을 수 있는데, 거기에 답이 있다. 다른 Host들 간 통신에는 반드시 네트워크가 필요한 반면에, Host 내부 통신이라면 네트워크가 필요없다는 것이다. 즉, UDS는 네트워크 통신이 필요없는 Host 내부 프로세스 간 통신에 사용된다.UDS를 사용할 경우 기존에 사용한 TCP/UDP system call을 그대로 사용할 수 있다는 장점이 있다.1. include#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;-----------------------------------------#include &lt;sys/un.h&gt;점선 위로는 기존 TCP/UDP 통신에 필요한 헤더이며, 점선 아래로는 UDS를 사용하기 위한 추가 헤더이다.2. socket 생성int socket(int domain, int type, int protocol);기존의 함수를 그대로 사용하며, 매개변수도 동일한 유형이나 다음의 차이가 존재한다. domain 기존 : PF_INET / PF_INET6(IPv6) 변경 : PF_FILE int socket = socket(PF_FILE, SOCK_STREAM, 0);int socket = socket(PF_FILE, SOCK_DGRAM, 0); 3. bindint bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);bind도 동일한 API를 사용하나 2번째 매개변수인 addr이 sockaddr_in에서 sockaddr_un으로 변경된다는 차이점이 있다.struct sockaddr_un { __SOCKADDR_COMMON (sun_); (= sa_family_t sa_prefix;) char sun_path[108]; /* Path name. */ };struct sockaddr_un servAddr;memset(&amp;servAddr, 0x00, sizeof(servAddr));servAddr.sun_family = AF_UNIX;snprintf(servAddr.sun_path, sizeof(servAddr.sun_path), \"%s\", FILE_NAME);unsigned int servAddrLen = sizeof(servAddr); sun_family TCP/UDP에서 설정했던 family 종류와 동일하다. 다만, UDS이므로 AF_UNIX 또는 AF_FILE 또는 AF_LOCAL을 지정해야 한다. 위의 3가지 family 변수는 모두 PF_LOCAL 변수의 alias이며 실제 값은 1이다. (The AF_UNIX (also known as AF_LOCAL) socket family is used to communicate between processes on the same machine efficiently.) sun_path 통신에 사용될 파일시스템 내 파일 경로를 지정한다. snprintf를 사용해 대상 파일명을 입력하는 것이 일반적이다. snprintf(servAddr.sun_path, sizeof(servAddr.sun_path), \"%s\", FILE_NAME); **주의해야 할 점은, UDS 소켓 파일은 bind 함수 실행 시점에 존재하지 않아야 한다.그러므로 bind 실행 이전 소켓 파일의 존재 여부를 확인한 후 있을 경우 파일을 삭제해야 한다.**if (access(FILE_NAME, F_OK) != 0) { unlink(FILE_NAME);}// 이후 bind 실행....4. listenint listen(int sockfd, int backlog);변경사항 없이, 기존의 TCP/UDP와 동일하게 사용하면 된다.5. connectint connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);2번째 매개변수에 사용되는 구조체는 sockaddr_un 구조체이다.일반 TCP/IP 소켓 프로그래밍처럼 형변환하여 사용한다.int result = connect(serverSock, (struct sockaddr*)&amp;servAddr, servAddrLen);if (result == -1) { perror(\"connect() failed\"); return;}6. acceptint accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);2번째 매개변수에 사용되는 구조체는 sockaddr_un 구조체이다.connect와 동일하게 형변환하여 사용하며, 필요하지 않을 경우에는 NULL을 넣어도 상관없음.int clientSock = accept(servSock, (struct sockaddr*) &amp;clientAddr, &amp;clientAddrLen);if (clientSock == -1) { perror(\"accept() failed\"); return;}7-1. sendssize_t send(int sockfd, const void *buf, size_t len, int flags);7-2. writessize_t write(int fd, const void *buf, size_t count);8-1. recvssize_t recv(int sockfd, void *buf, size_t len, int flags);8-2. readssize_t read(int fd, void *buf, size_t count);위의 명시된 4개의 함수는 이미 생성된 소켓을 통해 데이터를 송/수신하는 데에 사용되므로UDS - TCP/IP 통신의 성격에 영향을 받지 않는다." }, { "title": "[스레드 풀/Thread Pool] 스레드 풀의 적정 크기는? / 스레드 풀의 적절한 사이즈는", "url": "/posts/%EC%8A%A4%EB%A0%88%EB%93%9C%ED%92%80%EC%9D%98_%EC%A0%81%EC%A0%95%EC%82%AC%EC%9D%B4%EC%A6%88/", "categories": "Development, Etc", "tags": "Thread, 스레드, 동시성", "date": "2022-11-10 21:04:10 +0900", "snippet": "스레드 풀의 적정 사이즈는 어느 정도일까요? 1개? 2개? 또는 최대한 많이? 적절한 답을 찾지 못해 구글링하던 도중 이에 대해 잘 정리된 글을 읽고 번역해보았습니다. 다소 부족한 부분이 있더라도 양해 부탁드리며, 원문을 보고 싶으시다면 다음을 참고 바랍니다.원문 : https://jobs.zalando.com/tech/blog/how-to-set-an-ideal-thread-pool-size/?gh_src=4n3gxh1자바에서 스레드를 생성하는 것은 공짜가 아니다! 실제 오버헤드는 플랫폼마다 다르겠지만, 스레드가 생성될 때는 요청이 처리되는 지연 시간이 발생하고 JVM과 OS에 의한 추가적인 처리 과정이 필요하다. 그렇기 때문에 스레드 풀이 필요하다. 스레드 풀은 현재의 작업을 수행하기 위해 이전에 생성된 스레드 풀을 재사용함으로써 사이클 오버헤드 및 자원 낭비를 막을 수 있다.(역주 - 자원 낭비(problem of resource thrashing) - thrashing은 CPU가 작업 수행 시간보다 페이징 교체에 더 많은 시간을 소모하는 것을 의미. 즉 page fault가 많은 상황에 발생)이 글에서는 최적의 스레드 풀 사이즈에 대해 얘기하려고 한다. 잘 조정된 스레드 풀은 시스템의 최대치를 이끌어낼 수 있으며 최대치의 부하를 받을 때에도 올바르게 동작할 수 있다. 반면에 엉망인 스레드 풀을 사용할 경우, 스레드 풀이 있음에도 병목현상이 발생하거나 스레드 풀로 인해 프로그램이 죽을 수도 있다.스레드 풀에 제한을 걸어야 하는 이유는?여기에 Executors.newChachedThread을 구현한 코드가 있다. 우리는 왜 다음 코드를 그냥 쓰면 안 될까?/** Thread Pool constructor */public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue {\t...} /** Cached Thread Pool */public static ExecutorService newCachedThreadPool() {\treturn new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());}위 코드에서 스레드를 생성하는 데에 사용되는 SynchronousQueue는 풀 안에 있는 모든 스레드가 busy 상태일 경우 새로운 작업이 발생하면 새로운 스레드가 생성되는 것을 의미한다.이는 자원의 추가 소모를 의미하고, 위 코드를 그대로 사용했을 때 만약 엄청나게 많은 요청이 발생한다면, 스레드가 계속 생성되다가 결국 OOM이 발생할 것이다.즉 사용자 세션마다 스레드를 생성하게 된다면 DDoS와 동일한 문제가 발생하는 것이며, 서버는 이러한 상황이 발생하지 않도록 자원을 최대한 아껴야 한다.네 한계를 알라첫번째로, 스레드 풀의 사이즈를 조정하기 전에 관련된 환경의 제약 사항을 확실히 이해해야만 한다. 이는 하드웨어만을 의미하는 것이 아니다. 예를 들어 특정 스레드(worker)가 DB와 연관된 작업을 할 경우, 스레드 풀은 DB의 Connection Pool size에 영향을 받을 것이다. 동시접속이 100개만 가능한 DB에 크기가 1000인 스레드 풀이 있다고 하면, 과연 스레드 풀은 효율적으로 동작할 수 있을까? 한 스레드가 n개의 동시 요청을 처리할 수 있는 외부 서비스를 호출할 때, 스레드 풀의 크기는 이 ‘외부 서비스’의 성능에 따라 좌우된다.이는 당연하지만 우리가 종종 잊는 것이다.두번째로, 스레드 풀에게 중요한 자원 중 하나는 CPU다. 우리는 CPU의 전체 개수를 다음과 같이 구할 수 있다.(Java)int numOfCores = Runtime.getRuntime().availableProcessors();(C)#include &lt;stdio.h&gt;#include &lt;sys/sysinfo.h&gt;printf(\"%d processors configured and %d processors available.\\n\", get_nprocs_conf(), get_nprocs()); (Python)import multiprocessingmultiprocessing.cpu_count()위 코드들은 우리가 이전부터 CPU의 개수를 구할 때 써온 방법이다. 하지만 Docker와 같은 컨테이너 환경에서 실행해야 하는 경우라면 이 명령어를 사용할 때 주의해야 한다. 명령어를 실행한 컨테이너가 아니라, 컨테이너들을 제어하는 부모 host의 하드웨어 환경을 볼 수도 있기 때문이다.이와 관련된 기사 2개를 첨부하겠으니 읽어보길 바란다.(https://mjg123.github.io/2018/01/10/Java-in-containers-jdk10.html)(https://jaxenter.com/nobody-puts-java-container-139373.html)세 번째로, 메모리와 File handler, Socket Handler 역시 중요하게 고려되어야 한다.(File Descriptor는 linux 환경일 경우 기본적으로 1024개까지 open 가능하다)공식Brian Goetz의 유명한 책인 “Java Concurrency in Practice”에서는 다음 공식이 등장한다.스레드 수 = 사용 가능한 코어 수 * (1+대기 시간/실제 수행시간)(역주 - (대기 시간/서비스 시간)의 값은 block 계수라고도 한다.)여기서 대기 시간은 작업 하나를 완료하기 위해 필요한 대기 시간, 즉 I/O waiting, 원격 서비스에 대한 HTTP response wating 등을 의미한다. 수행 시간은 대기 시간을 제외하고 작업이 실제로 동작 중인 시간, 즉 I/O waiting 이후 전달받은 데이터를 처리하는 과정을 의미한다.이 경우 CPU를 많이 쓰는 계산 작업의 경우 대기를 거의 하지 않으므로 (대기 시간/서비스 시간)의 값이 0에 수렴하므로, 스레드 풀의 최대 수는 사용 가능한 코어의 수와 동일하다. 만약 모든 작업이 계산 작업이라면 이 정도면 충분하다. 그 이상은 불필요하다.예) worker 스레드는 '요청에 대한 응답을 JSON으로 변환하고 몇 가지 규칙을 실행하는 'microservice’(이하 micro)' 를 호출한다. micro의 응답 시간은 50ms, 서비스 시간은 5ms이며 worker 스레드를 실행시키는 프로그램은 듀얼 코어 cpu에서 동작한다고 가정하자.이때 적절한 스레드 풀 사이즈는2 *(1+50/5) = 22가 된다.하지만 위의 예시는 너무 단순화되었다. 단순히 처리에만 중점을 두었기 때문에 HTTP 응답을 하는 대상 서버의 Connection Pool, JMS(자바 메시지 서비스) 요청, JDBC Connection Pool 과 같은 어플리케이션 외의 영역을 고려하지 않았다.만약 여러 클래스에서 각각의 스레드풀, 즉 한 프로세스에서 여러 개의 스레드풀이 존재하는 경우 각자의 워크로드에 따라 이 수치가 조정될 수 있다. 이 경우엔 CPU 목표 사용량을 추가하기만 하면 된다. 이때 CPU 목표 사용량은 0에서 1사이의 값이다.스레드 수 = 사용 가능한 코어 수 * CPU 목표 사용량 * (1+대기 시간/실제 수행시간)리틀의 법칙이 장에서는 최적화된 스레드 풀의 사이즈를 구할 것이다. 우리는 이론적인 최대치와 측정할 수 있는 항목이 있다. 하지만 어떻게 병렬 worker의 수가 지연 시간과 처리량을 변경할 수 있을까?리틀의 법칙은 이 질문에 대한 답이 될 수 있다. 이 법칙에서 시스템의 요청 수는 도착한 비율과 개별 요청을 처리하는 데 걸리는 평균 시간을 곱한 값과 같다. 이 공식을 사용하여 특정 대기 시간 수준에서 사전 정의된 처리량을 처리할 병렬 work 스레드의 수를 계산할 수 있을 것이다L = λ * WL - 동시에 처리된 요청 수λ – 평균 도착 시간(?)W – 요청이 처리되기까지의 평균 대기 시간이 공식을 이용하면, 우리는 시스템의 용량을 계산할 수 있다. 또는 안정적인 응답 시간이 보장되는, 1초당 발생하는 요청들을 다루기 위해 몇 개의 스레드가 동시에 동작해야 하는지 계산할 수 있다.우리의 예로 돌아가보자. 우리는 평균 응답 시간이 55ms이며 스레드풀의 크기가 22인 서비스를 갖고 있다.이 서비스에 대해 리틀의 법칙을 적용하면22 / 0.055 = 400 (우리 서비스가 안정적으로 응답을 처리할 수 있는 1초당 최대 요청 수)의 결과를 얻을 수 있다." }, { "title": "memset과 bzero의 차이점", "url": "/posts/memset_bzero/", "categories": "Development, C/C++", "tags": "TAG", "date": "2022-10-24 21:20:04 +0900", "snippet": "1. bzero#include void bzero(void *s, size_t n); 이름에서도 나타나듯이, zero의 값을 덮어씀 0x00의 값을 s 영역에 n 크기만큼 쓰며, 오직 0x00만의 값만 쓸 수 있다 쓰지 않기를 권장하는(deprecated된) 함수. 실제로 man bzero를 실행하면 다음 문구를 확인 가능 4.3BSD. This function is deprecated (marked as LEGACY inPOSIX.1-2001): use memset(3) in new programs. POSIX.1-2008removes the specification of bzero().2. memset#include void *memset(void *s, int c, size_t n); c로 지정된 값을 s의 영역에 byte 단위로 n 크기만큼 채운다 초기화에 사용될 값을 별도로 지정 가능 반환값 : 메모리 영역 s에 대한 시작 포인터#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(void) { char arr[10]; printf(\"%p\\n\", &amp;arr[0]); // 0x7ffc715b8ac0 printf(\"%p\\n\", memset(arr,0x00,sizeof(arr))); // 0x7ffc715b8ac0 printf(\"%p\\n\", &amp;arr[1]); // 0x7ffc715b8ac1} byte 단위를 강조한 이유는? 다음 코드를 실행해볼 것 #include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(void) { int arr[10]; memset(arr, 5, sizeof(arr)); printf(\"%d\\n\", arr[0]); // 5가 출력될까?} 5가 출력되지 않는 이유는? memset sets each byte of the destination buffer to the specified value. On your system, an int is four bytes, each of which is 5 after the call to memset. Thus, grid\\[0\\] has the value 0x05050505 (hexadecimal), which is 84215045 in decimal. memset은 byte 단위로 값을 채우는데, 위 코드에서 출력 대상으로 지정된 memset 대상으로 지정된 arr[0]은 int, 즉 4byte이다 따라서 0x05가 4번 채워지게 되므로, arr[0]의 내부 값은 0x05050505로 초기화된다. 0x05050505 = 84215045(10) " } ]
